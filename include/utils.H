# ifndef UTILS_H
# define UTILS_H

# include <sys/stat.h>
# include <stdlib.h>
# include <cstdlib>
# include <memory>
# include <cxxabi.h>
# include <string>
# include <sstream>
# include <typeinfo>

# include <ah-convert.H>
# include <htlist.H>
# include <tpl_array.H>

# define COMMENT SLASH(/)
# define SLASH(s) /##s

/** Given a linker symbol name generated by a c++ compiler, this
  functions decodes it into a user level name.
  
  @ingroup Utils
 */
inline std::string demangle(const char* name)
{
  int status = -4; // some arbitrary value to eliminate the compiler warning
  // enable c++11 by passing the flag -std=c++11 to g++
  std::unique_ptr<char, void(*)(void*)> res
    { abi::__cxa_demangle(name, NULL, NULL, &status), std::free };
  return (status==0) ? res.get() : name ;
}

/** Given a pointer, it returns the class name 
  
  @ingroup Utils
 */
# define CLASSNAME_TO_STRING(class_ptr) demangle(typeid(*class_ptr).name())

/** Print a error message and aborts

   @ingroup Utils
 */
inline void error_msg(const string & msg)
{
  cout << msg << endl;
  abort();
}

/** Return `true` if it exists a file of `name`

   @ingroup Utils
 */
inline bool exists_file(const string & name)
{
  struct stat buffer;
  return (stat (name.c_str(), &buffer) == 0);
}

/** Return a string with R specification of a vector with `name` and
   data stored in container `c`

   @ingroup Utils
 */
template <class C>
inline std::string Rvector(const std::string & name, const C & c)
{
  std::ostringstream s;
  s << name << " <- c(";
  auto last_ptr = &c.get_last();
  for (auto it = c.get_it(); it.has_curr(); it.next())
    {
      auto & v = it.get_curr();
      s << v;
      if (&v != last_ptr)
	s << ", ";
    }
  s << ")";

  return s.str();
}

template <class C>
inline std::string Rvector(const C & c)
{
  std::ostringstream s;
  s << c.get_first() << " <- c(";
  auto last_ptr = &c.get_last();
  for (auto it = c.get_it(1); it.has_curr(); it.next())
    {
      auto & v = it.get_curr();
      s << v;
      if (&v != last_ptr)
	s << ", ";
    }
  s << ")";

  return s.str();
}

/** Basic linear interpolation

   This function receives a pair of points in a plane plus a x point
   and computes the value of f(x) through linear interpolation

   @param[in] x1 minimum in x
   @param[in] x2 maximum in x
   @param[in] y1 value of f(x1)
   @param[in] y2 value of f(x2)
   @param[in] x for which f(x) should be computed
   @note `x1` must be greater or equal to `x2`

  @ingroup Utils
 */
inline
double interpolate(double x1, double x2, double y1, double y2, double x)
{
  assert(x2 >= x1 and x <= x2 and x >= x1);
  return y1 + (y2 - y1)*(x - x1)/(x2 - x1);
}    

/** Basic linear extrapolation

   This function receives a pair of points in a plane plus a x point
   less than `x1` and `x2` and computes the value of f(x) 

   @param[in] x1 minimum in x
   @param[in] x2 maximum in x
   @param[in] y1 value of f(x1)
   @param[in] y2 value of f(x2)
   @param[in] x for which f(x) should be computed
   @note `x1` must be greater or equal to `x2` and `x` must be less
   than `x1`

   @ingroup Utils
 */
inline
double extrapolate_left(double x1, double x2, double y1, double y2, double x)
{
  assert(x2 >= x1 and x < x1);
  return y1 - (y2 - y1)*(x1 - x)/(x2 - x1);
}

/** Return x^2
   @ingroup Utils
 */
inline double pow2(double x) { return x*x; }

/** Return x^3
   @ingroup Utils
 */
inline double pow3(double x) { return x*pow2(x); }

/** Basic linear extrapolation

   This function receives a pair of points in a plane plus a x point
   less than `x1` and `x2` and computes the value of f(x) 

   @param[in] x1 minimum in x
   @param[in] x2 maximum in x
   @param[in] y1 value of f(x1)
   @param[in] y2 value of f(x2)
   @param[in] x for which f(x) should be computed
   @note `x1` must be greater or equal to `x2` and `x` must be greater 
   than `x2`

   @ingroup Utils
 */
inline
double extrapolate_right(double x1, double x2, double y1, double y2, double x)
{
  assert(x2 >= x1 and x > x2);
  return y2 - (y2 - y1)*(x - x2)/(x2 - x1);
}    

/** Return the next representable floating-point value to `val`

   @ingroup Utils
 */
inline double next_value(double val)
{
  return nextafter(val, numeric_limits<double>::max());
}

/** Return the previousv representable floating-point value to `val`

    @ingroup Utils
 */
inline double prev_value(double val)
{
  return nextafter(val, numeric_limits<double>::min());
}

/** Generate and execute a R script from a string (containing the script)

    @param[in] scr string containing the script
    @param[in] file name of temporal file where the script will be saved

   @ingroup Utils
 */
void execute_R_script(const string & scr, const string & file_name = "tmp.R")
{
  ofstream tmp(file_name);
  tmp << "#!/usr/bin/Rscript" << endl
      << endl
      << "X11()" << endl
      << scr << endl
      << "message(\"Press Return To Continue\")" << endl
      << "invisible(readLines(\"stdin\", n=1))" << endl;
  const string cmd = "Rscript " + file_name;
  system(cmd.c_str());
}


# endif // UTILS_H




