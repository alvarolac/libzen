# include <iostream>

# include <ah-stl-utils.H>

# include <units-list.H>

# include <json.hpp>

using json = nlohmann::json;

static void init_unit_converters();

// the following data is declared in units.H
UnitItemTable * PhysicalQuantity::tbl = nullptr;

UnitItemTable * Unit::tbl = nullptr;

DynSetTree<const Unit *> * Unit::unit_tbl = nullptr;

static size_t
name_unit_pair_hash(const pair<pair<string, string>, Unit_Convert_Fct_Ptr> & p)
{
  const auto & f = p.first;
  return dft_hash_fct(f.first) + dft_hash_fct(f.second);
}

static size_t fst_unit_pair_hash
(const pair<pair<const Unit*, const Unit*>, Unit_Convert_Fct_Ptr> & p)
{
  return dft_hash_fct(p.first);
}

static size_t snd_unit_pair_hash
(const pair<pair<const Unit*, const Unit*>, Unit_Convert_Fct_Ptr> & p)
{
  return snd_hash_fct(p.first);
}

UnitHashTbl * __unit_name_name_tbl = nullptr;
UnitHashTbl * __unit_name_symbol_tbl = nullptr;
UnitHashTbl * __unit_symbol_name_tbl = nullptr;
UnitHashTbl * __unit_symbol_symbol_tbl = nullptr;
UnitMap * __unit_map = nullptr;
CompoundUnitTbl * __compound_unit_tbl = nullptr;

const PhysicalQuantity PhysicalQuantity::null_physical_quantity;

const Unit Unit::null_unit;

double Unit::Invalid_Value = 0;

const VtlQuantity VtlQuantity::null_quantity;

UnitsInstancer::UnitsInstancer()
{
  static UnitItemTable physicalquantity_tbl;
  static UnitItemTable unit_tbl;
  static DynSetTree<const Unit *> unit_unit_tbl;

  PhysicalQuantity::tbl = &physicalquantity_tbl;
  Unit::tbl = &unit_tbl;
  Unit::unit_tbl = &unit_unit_tbl;

  static UnitHashTbl __unit_name_name_tbl(500, name_unit_pair_hash);
  ::__unit_name_name_tbl = &__unit_name_name_tbl;

  static UnitHashTbl __unit_name_symbol_tbl(500, name_unit_pair_hash);
  ::__unit_name_symbol_tbl = &__unit_name_symbol_tbl;

  static UnitHashTbl __unit_symbol_name_tbl(500, name_unit_pair_hash);
  ::__unit_symbol_name_tbl = &__unit_symbol_name_tbl;

  static UnitHashTbl __unit_symbol_symbol_tbl(500, name_unit_pair_hash);
  ::__unit_symbol_symbol_tbl = &__unit_symbol_symbol_tbl;

  static UnitMap __unit_map(3000, fst_unit_pair_hash, snd_unit_pair_hash);
  ::__unit_map = &__unit_map;

  static CompoundUnitTbl __compound_unit_tbl;
  ::__compound_unit_tbl = &__compound_unit_tbl;

  new ((void*) &PhysicalQuantity::null_physical_quantity)
    PhysicalQuantity("NullPhysicalQuantity", "NullPQ",
		     "Null" "Null Physical Quantity");

  new ((void*) &Unit::null_unit) Unit("NullUnit", "Null Unit", "Null unit", "Null",
				      PhysicalQuantity::null_physical_quantity,
				      numeric_limits<double>::min(),
				      numeric_limits<double>::max());

  new ((void*) &Unit::Invalid_Value) double(numeric_limits<double>::max());

  new ((void*) &VtlQuantity::null_quantity)
    VtlQuantity(Unit::null_unit, numeric_limits<double>::max());

  init_unit_converters();
}

bool conversion_exist(const char * src_symbol, const char * tgt_symbol)
{
  //std::lock_guard<std::mutex> critical_section(unit_mutex);
  return exist_conversion(src_symbol, tgt_symbol);
}

double unit_convert(const char * src_symbol, const char * tgt_symbol,
		    double val)
{
  //std::lock_guard<std::mutex> critical_section(unit_mutex);
  return unit_convert_symbol_to_symbol(src_symbol, val, tgt_symbol);
}

static json to_json(const Unit * unit_ptr)
{
  json j;
  j["name"] = unit_ptr->name;
  j["description"] = unit_ptr->description;
  j["symbol"] = unit_ptr->symbol;
  j["latex_symbol"] = unit_ptr->latex_symbol;
  j["minimum_value"] = unit_ptr->min_val;
  j["maximum_value"] = unit_ptr->max_val;
  j["epsilon"] = unit_ptr->get_epsilon();
  return j;
}

static json to_json(const PhysicalQuantity * const pq)
{
  json j;
  j["name"] = pq->name;
  j["description"] = pq->description;
  j["symbol"] = pq->symbol;
  j["latex_symbol"] = pq->latex_symbol;
  j["units"] =
    to_vector(pq->units().maps<json>([] (auto p) { return to_json(p); }));
  
  return j;
}

string units_json()
{
  json j;
  j["Zen_physical_quantities"] =
    to_vector(PhysicalQuantity::quantities().maps<json>([] (auto p)
    { return to_json(p); }));
  return j.dump(2);
}

const UnitsInstancer & units_instance = UnitsInstancer::init();

// The following global singleton variables are generated by extract-cv script
